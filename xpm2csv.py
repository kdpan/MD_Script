#!/usr/bin/env python

import sys
# from tap import Tap
from pathlib import Path
from typing import Dict, Any
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""
Utility tool to convert xpm files generated by GROMACS to a 3-column text file.
"""

usage = """USAGE: xpm2txt.py -f <input xpm file> -o <output txt file> [-s]
"""


# class MyArgumentParser(Tap):
#     f: Path  # input xpm file
#     o: Path  # output txt file
#     s: int = 9999  # Sorts the output by a given column


def parse_xpm(xpm_file: Path) -> tuple[list[str], Any, Any, Dict[str, float]]:

    # Parse XPM file
    xpm_data: list[str] = []
    x_axis: list[float] = []
    y_axis: list[float] = []
    letter_to_value: Dict[str, float] = {}

    with open(Path(xpm_file), "r") as xpm_input:
        for line in xpm_input:
            if line.startswith("/* x-axis"):
                x_axis = list(map(float, line.split()[2:-2]))  # We trim the last value

            if line.startswith("/* y-axis"):
                y_axis = list(map(float, line.split()[2:-2]))  # We trim the last value

            if line.startswith('"') and x_axis and y_axis:  # Read data
                xpm_data.insert(0, line.strip().strip(",")[1:-1])

            if line.startswith('"') and len(line.split()) > 4:
                letter = line.split()[0][1:]
                value = float(line.split()[-2][1:-1])
                letter_to_value[letter] = value

    return (xpm_data, x_axis, y_axis, letter_to_value)


def match_data(
    xpm_data: list[str], x_axis: Any, y_axis: Any, letter_to_value: Dict[str, float]
) -> list[list[float]]:

    # Match x/y/data

    txt_values: list[list[float]] = []
    for y_index, data_value in enumerate(xpm_data):
        y_value: float = y_axis[y_index]
        letter= ''
        for x_index, x_value in enumerate(x_axis):
            letter += data_value[x_index]
            if len(letter) == 2:
                txt_values.append([x_value, y_value, letter_to_value[letter]])
                letter= ''
    return txt_values


def apply_sorting(column_sort: int, txt_values: list[list[float]]) -> None:

    # Apply sorting
    try:
        txt_values.sort(key=lambda x: x[column_sort - 1])
    except IndexError:
        print(usage)
        print(f"ERROR: Column not found ({column_sort})\n")
        sys.exit()


def save_to_csv(txt_values: list[list[float]], output_file: Path) -> None:
    data = pd.DataFrame(columns=['x','y','z'])
    data.to_csv(output_file,mode='w',index=None)
    n = 0
    for x,y,z in txt_values:
        data.loc[n] = [x,y,z]
        n+=1
    data.to_csv(output_file,mode='a',index=None,header=None)
    data = pd.DataFrame(columns=['x','y','z'])
    

if __name__ == "__main__":

    # args = MyArgumentParser().parse_args()

    xpm_file = 'data/FEL_sham.xpm'
    columns_sort = 9999
    output_file = 'data/FEL_sham.csv'
    output_file_fig = 'data/FEL.png'

    parsed_data: tuple[list[str], Any, Any, Dict[str, float]] = parse_xpm(Path(xpm_file))
    matched_data: list[list[float]] = match_data(
        parsed_data[0], parsed_data[1], parsed_data[2], parsed_data[3]
    )

    if columns_sort != 9999:
        apply_sorting(columns_sort, matched_data)
    save_to_csv(matched_data, Path(output_file))

